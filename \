// Merge K Sorted Lists
// https://leetcode.com/problems/merge-k-sorted-lists/description/

fn main() {
    let input = vec![
        create_list(ListNode::from_vec(vec![1,4,5])),
        create_list(ListNode::from_vec(vec![1,3,4])),
        create_list(ListNode::from_vec(vec![2,6])),
    ];
    let answer = create_list(ListNode::from_vec(vec![1,1,2,3,4,4,5,6]));
    let output = Solution::merge_k_lists(input);
    
    assert_eq!(answer, output);
}

#[derive(PartialEq, Eq, Debug, Clone)]
pub struct ListNode {
    pub val: i32,
    pub next: Option<Box<ListNode>>
}

impl ListNode {
    #[inline]
    pub fn new(val: i32) -> Self {
        ListNode {
            val,
            next: None,
        }
    }
    
    pub fn from_vec(vals: Vec<i32>) -> Self {
        let mut list = ListNode::new(vals[0]);
        for val in vals[1..].iter() {
            list.push(*val);
        }
        list
    }

    pub fn push(&mut self, val: i32) {
        let mut current = &mut self.next;
        while let Some(node) = current {
            current = &mut node.next;
        }

        let node = ListNode::new(val);
        *current = Some(Box::new(node));
    }
}

pub fn create_list(node: ListNode) -> Option<Box<ListNode>> {
    Some(Box::new(node))
}

struct Solution;
impl Solution {
    pub fn merge_k_lists(lists: &[Option<Box<ListNode>>]) -> Option<Box<ListNode>> {
        if lists.is_empty() {
            return None;
        }

        let len = lists.len();

        if len == 1 {
            return lists[0].clone();
        }

        let middle = len / 2;
        let (left_half, right_half) = lists.split_at_mut(middle);

        let left_sorted = Self::merge_k_lists(left_half.to_vec());
        let right_sorted = Self::merge_k_lists(right_half.to_vec());

        Self::merge(left_sorted, right_sorted)
    }

    fn merge(left: Option<Box<ListNode>>, right: Option<Box<ListNode>>) -> Option<Box<ListNode>> {
        unimplemented!()
    }

}
